<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>6</storyId>
    <title>monitoring-logging-foundation</title>
    <status>drafted</status>
    <generatedAt>2025-11-13</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>.bmad-ephemeral/stories/1-6-monitoring-logging-foundation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>ops engineer</asA>
    <iWant>basic logging and health monitoring in place</iWant>
    <soThat>I can identify and debug issues quickly in dev and prod</soThat>
    <tasks>Task 1: Implement structured JSON logging for all services (AC: 2, 4)
- Configure Winston logging for Suna (Next.js) with JSON format
- Configure Python logging for Onyx Core with JSON format
- Implement structured logging for Nginx with JSON format
- Add proper severity levels (info, warn, error, debug)
- Include request ID tracking for distributed tracing

Task 2: Configure log aggregation and centralized viewing (AC: 3)
- Configure Docker Compose logging driver for JSON format
- Set up log rotation and retention policies
- Implement centralized log viewing with docker compose logs
- Add timestamp standardization across services
- Document log access and debugging procedures

Task 3: Enhance health check endpoints (AC: 5)
- Implement /health endpoint for Suna with service status
- Implement /health endpoint for Onyx Core with dependencies check
- Enhance Nginx health check with upstream service status
- Add database connectivity checks to health endpoints
- Create health check monitoring and alerting

Task 4: Implement Prometheus metrics endpoints (AC: 6)
- Add prometheus client to Suna for frontend metrics
- Add prometheus client to Onyx Core for backend metrics
- Implement basic metrics: request count, response time, error rate
- Configure /metrics endpoint for each service
- Document metrics collection and monitoring setup</tasks>
  </story>

  <acceptanceCriteria>Given: All services running
When: Services log to stdout in structured JSON format
Then: docker compose logs shows aggregated service logs with timestamps
And: Each service includes request/error logs with proper severity levels
And: Health check endpoints (/health) return JSON status with service details
And: Prometheus metrics endpoint available at /metrics (basic implementation)</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/epics.md" title="ONYX Epics & Stories Breakdown" section="Story 1.6: Monitoring & Logging Foundation" snippet="Foundation monitoring and logging with structured JSON output. AC1.6.1: All services log to stdout in structured JSON format, AC1.6.2: docker compose logs shows aggregated service logs with timestamps, AC1.6.3: Each service includes request/error logs with proper severity levels, AC1.6.4: Health check endpoints (/health) return JSON status with service details, AC1.6.5: Prometheus metrics endpoint available at /metrics (basic implementation)" />
      <doc path="docs/architecture.md" title="ONYX Architecture Document" section="Monitoring and Logging" snippet="Logging: Structured JSON logs → centralized (Observability). Monitoring: Prometheus + Grafana (Observability). Error Tracking: Sentry (optional, self-hosted) (Error aggregation)" />
      <doc path=".bmad-ephemeral/stories/tech-spec-epic-1.md" title="Epic Technical Specification: Foundation & Infrastructure" section="Story 1.6: Monitoring & Logging Foundation" snippet="Foundation monitoring and logging with structured JSON output. Out-of-Scope: Advanced monitoring (Prometheus/Grafana - Epic 9)" />
      <doc path="docker-compose.yaml" title="Docker Compose Configuration" section="Logging Configuration" snippet="Logging configuration: LOG_LEVEL: info, LOG_FORMAT: json, NEXT_PUBLIC_LOG_LEVEL: info, NEXT_PUBLIC_SERVICE_NAME: suna-frontend, NEXT_PUBLIC_ENABLE_REMOTE_LOGGING: false. Health check: test: [CMD, curl, -f, http://localhost:3000/api/health]" />
      <doc path="docs/environment-variable-precedence.md" title="Environment Variable Precedence" section="Environment Loading Order" snippet="Environment variables are loaded in order: Docker Secrets (highest) → Environment Files → Shell Environment → Docker Compose Environment Section (lowest). File precedence: .env.local > .env.development > .env.staging > .env.production > .env.example" />
    </docs>
    <code>
      <code path="suna/src/app/api/health/health.js" kind="api-endpoint" symbol="handler" lines="4-34" reason="Existing health check endpoint for Suna frontend - needs enhancement with structured JSON and service details">
        Basic health check returning status, timestamp, responseTime, version, environment, services, uptime. Uses standard HTTP status codes.
      </code>
      <code path="onyx-core/health.py" kind="api-endpoint" symbol="health_check" lines="103-177" reason="Comprehensive health check with dependency monitoring - excellent foundation for enhancement">
        Full health check system with async dependency checks for database, Qdrant, Redis, Google API. Returns structured JSON with service status, response times, and overall health determination.
      </code>
      <code path="onyx-core/main.py" kind="main-application" symbol="app" lines="42-66" reason="FastAPI application setup with health router included - shows integration pattern">
        FastAPI app configuration with CORS, health router inclusion, lifecycle management, and existing logging setup using Python's standard logging.
      </code>
      <code path="onyx-core/logger.py" kind="logging-utility" symbol="StructuredLogger" lines="19-146" reason="Complete structured JSON logging implementation - excellent foundation already exists">
        Comprehensive structured logging system with JSON formatter, service context, timing utilities, error handling, and convenience functions. Already outputs JSON format to stdout.
      </code>
      <code path="nginx/nginx.conf" kind="configuration" symbol="log_format" lines="9-17" reason="Nginx logging configuration - traditional format, needs conversion to JSON">
        Standard Nginx log format with upstream timing. Current format is traditional text, needs conversion to JSON for consistency.
      </code>
      <code path="nginx/logging.conf" kind="configuration" symbol="json_combined" lines="6-26" reason="JSON logging format already defined - ready to use">
        Complete JSON log format for Nginx with timestamp, method, URI, status, upstream metrics, request tracking. Already prepared for structured logging.
      </code>
      <code path="docker-compose.yaml" kind="configuration" symbol="logging-environment" lines="19-24" reason="Environment variables for logging configuration already in place">
        LOG_LEVEL, LOG_FORMAT, NEXT_PUBLIC_LOG_LEVEL, NEXT_PUBLIC_SERVICE_NAME configured. Shows environment-based logging setup pattern.
      </code>
    </code>
    <dependencies>
    <ecosystem name="Python">
      <package name="prometheus-client" version="0.19.0" purpose="Prometheus metrics collection and endpoint implementation" />
      <package name="structlog" version="23.2.0" purpose="Structured JSON logging (alternative to custom logger)" />
      <package name="fastapi" version="0.104.1" purpose="Web framework with health check endpoints" />
      <package name="uvicorn" version="0.24.0" purpose="ASGI server with built-in logging support" />
      <package name="pydantic" version="2.5.0" purpose="Data validation and health response models" />
      <package name="sqlalchemy" version="2.0.23" purpose="Database health check connectivity" />
      <package name="qdrant-client" version="1.15.0" purpose="Vector database health checks" />
      <package name="redis" version="5.0.1" purpose="Cache service health checks" />
      <package name="httpx" version="0.25.2" purpose="HTTP client for external service health checks" />
    </ecosystem>
    <ecosystem name="Node.js/Next.js">
      <package name="next" version="^14.0.0" purpose="Next.js framework with API routes" />
      <package name="winston" version="to-be-added" purpose="Structured logging library for Node.js" />
      <package name="prom-client" version="to-be-added" purpose="Prometheus client for Node.js metrics" />
      <package name="react" version="^18.0.0" purpose="React framework for frontend" />
    </ecosystem>
    <ecosystem name="Infrastructure">
      <framework name="Nginx" version="latest" purpose="Reverse proxy with JSON logging configuration" />
      <framework name="Docker Compose" version="v2.20+" purpose="Container orchestration with log aggregation" />
      <framework name="Prometheus" version="latest" purpose="Metrics collection system (basic implementation)" />
    </ecosystem>
  </dependencies>
  </artifacts>

  <constraints>
    <constraint type="logging-format" rule="All services must output structured JSON logs to stdout" reason="Specified in Epic 1.6 AC1.6.1 and architecture docs" />
    <constraint type="health-checks" rule="All services must implement /health endpoint returning JSON with service details" reason="Specified in Epic 1.6 AC1.6.4 and existing health check patterns" />
    <constraint type="severity-levels" rule="Use standard severity levels: info, warn, error, debug" reason="Consistent with existing StructuredLogger implementation" />
    <constraint type="request-tracking" rule="Include request IDs for distributed tracing across services" reason="Required for debugging distributed requests" />
    <constraint type="environment-configuration" rule="Use environment variables for service-specific logging settings" reason="Follows established .env loading pattern" />
    <constraint type="metrics-endpoint" rule="Implement /metrics endpoint with basic Prometheus format" reason="AC1.6.5 requirement for metrics collection" />
    <constraint type="timestamp-standardization" rule="Use ISO 8601 format for all timestamps" reason="Consistent with existing logging implementation" />
  </constraints>
  <interfaces>
    <interface name="Health Check API" kind="REST endpoint" signature="GET /health → JSON {status, timestamp, services, response_time, version}" path="onyx-core/health.py:103-177" />
    <interface name="Readiness Check" kind="REST endpoint" signature="GET /health/ready → JSON {status: ready}" path="onyx-core/health.py:179-183" />
    <interface name="Liveness Check" kind="REST endpoint" signature="GET /health/live → JSON {status: alive}" path="onyx-core/health.py:186-190" />
    <interface name="Structured Logger" kind="Python class" signature="StructuredLogger(service_name).info(action, details, user_id)" path="onyx-core/logger.py:19-146" />
    <interface name="Health Response Model" kind="Pydantic model" signature="HealthResponse(status, timestamp, response_time, version, environment, services, uptime)" path="onyx-core/health.py:12-19" />
    <interface name="Service Health Model" kind="Pydantic model" signature="ServiceHealth(status, error?, response_time)" path="onyx-core/health.py:22-26" />
    <interface name="Metrics Endpoint" kind="Prometheus endpoint" signature="GET /metrics → Prometheus exposition format" path="to-be-implemented" />
  </interfaces>
  <tests>
    <standards>Project uses Jest for JavaScript/TypeScript testing with React Testing Library and JSDOM environment. Python testing uses pytest with pytest-asyncio for async functions. All tests should verify structured JSON log format, health check endpoint responses, and Prometheus metrics format. Test coverage minimum 80% required for monitoring components.</standards>
    <locations>
      <location type="frontend" path="suna/__tests__/" pattern="*.test.js" />
      <location type="frontend" path="suna/__tests__/" pattern="*.test.tsx" />
      <location type="backend" path="onyx-core/tests/" pattern="test_*.py" />
      <location type="integration" path="tests/" pattern="test_*_integration.py" />
    </locations>
    <ideas>
      <test id="ac1.6.1" description="Test structured JSON logging format for all services">
        <scenario>Verify all services output JSON logs with correct schema (timestamp, level, service, message, metadata)</scenario>
        <verification>Parse service stdout logs and validate JSON structure and required fields</verification>
      </test>
      <test id="ac1.6.2" description="Test Docker Compose log aggregation">
        <scenario>Run docker compose logs and verify aggregated output with timestamps</scenario>
        <verification>Execute docker compose logs command and validate log aggregation and timestamp consistency</verification>
      </test>
      <test id="ac1.6.3" description="Test severity levels and request/error logging">
        <scenario>Test different log levels (info, warn, error, debug) and request/error scenarios</scenario>
        <verification>Verify correct severity categorization and error handling in logs</verification>
      </test>
      <test id="ac1.6.4" description="Test health check endpoints return JSON status">
        <scenario>Call /health endpoints for Suna, Onyx Core, and Nginx services</scenario>
        <verification>Validate JSON response format with service details and dependency status</verification>
      </test>
      <test id="ac1.6.5" description="Test Prometheus metrics endpoint">
        <scenario>Call /metrics endpoints and validate Prometheus exposition format</scenario>
        <verification>Verify metrics format includes request count, response time, error rate counters</verification>
      </test>
      <test id="performance" description="Test logging performance impact">
        <scenario>Measure service startup time and request latency with logging enabled</scenario>
        <verification>Ensure logging overhead < 10ms per request and < 50ms startup impact</verification>
      </test>
      <test id="integration" description="End-to-end monitoring workflow test">
        <scenario>Trigger actions across all services and verify complete logging and health monitoring</scenario>
        <verification>Validate distributed request tracking and service health interdependencies</verification>
      </test>
    </ideas>
  </tests>
</story-context>